import { $ } from "bun";
import { z } from "zod";

const DefaultsConfig = z
  .object({
    link: z
      .object({
        // When true, create parent directories to the link as needed. (default: false)
        create: z.boolean().default(false),
        // Removes the old link if it's a symlink (default: false)
        relink: z.boolean().default(false),
        // Force removes the old link, file or folder, and forces a new link (default: false)
        force: z.boolean().default(false),
      })
      .default({
        create: false,
        relink: false,
        force: false,
      }),
  })
  .default({
    link: {
      create: false,
      relink: false,
      force: false,
    },
  });

const ShellConfigSchema = z.object({
  description: z.string().optional(),
  command: z.string(),
  quiet: z.boolean().optional().default(false),
});

const PackageManagerConfigSchema = z.object({
  // Important for Brew on MacOS
  installSelf: z.boolean().optional().default(true),
  dependenciesFile: z.string(),
});

// Define your config schema with Zod
const ConfigSchema = z.object({
  defaults: DefaultsConfig,
  link: z.record(z.string(), z.string()),
  shell: z.array(ShellConfigSchema),
  packageManager: PackageManagerConfigSchema,
});

type Config = z.infer<typeof ConfigSchema>;

const generateShell = (config: Config): string => {
  let output = "#!/bin/bash\n\n";
  output += "# Generated by dotbash\n";

  // Exit on error
  output += "set -e\n\n";

  output += generateLinks(config);

  return output;
};

const generateLinks = (config: Config): string => {
  let output = "";
  const linkDefaults = config.defaults.link;

  // Generate Links
  for (const [destination, source] of Object.entries(config.link)) {
    output += `echo "Setting up: ${destination} -> ${source}"\n`;

    // Get the source path relative to the dotfiles directory
    const sourcePath = `\$(pwd)/${source}`;

    // Expand tilde in destination path
    const destPath = destination.startsWith("~")
      ? `\$HOME${destination.slice(1)}`
      : destination;

    // Check source exists in shell (better for runtime validation)
    output += `if [ ! -e "${sourcePath}" ]; then\n`;
    output += `  echo "  ✗ Error: Source does not exist: ${source}"\n`;
    output += `  exit 1\n`;
    output += `fi\n`;

    // Create parent directory if needed
    if (linkDefaults.create) {
      output += `mkdir -p "\$(dirname "${destPath}")"\n`;
    }

    // Handle existing links/files
    if (linkDefaults.force) {
      // Force remove anything at the destination
      output += `if [ -e "${destPath}" ] || [ -L "${destPath}" ]; then\n`;
      output += `  echo "  Removing existing: ${destination}"\n`;
      output += `  rm -rf "${destPath}"\n`;
      output += `fi\n`;
    } else if (linkDefaults.relink) {
      // Only remove if it's a symlink
      output += `if [ -L "${destPath}" ]; then\n`;
      output += `  echo "  Removing existing symlink: ${destination}"\n`;
      output += `  rm "${destPath}"\n`;
      output += `fi\n`;
    }

    // Create the symlink
    output += `ln -s "${sourcePath}" "${destPath}"\n`;
    output += `echo "  ✓ Linked ${destination}"\n\n`;
  }

  output += 'echo "All symlinks created successfully!"\n';

  return output;
};

export const parseConfig = async (input: string, output: string) => {
  const configFile = Bun.file(input);
  const rawConfig = await configFile.json();

  const config = ConfigSchema.parse(rawConfig);

  const generatedShell = generateShell(config);
  Bun.file(output).write(generatedShell);
};
