import { $ } from "bun";
import { z } from "zod";

const DefaultsConfig = z
  .object({
    link: z
      .object({
        // When true, create parent directories to the link as needed. (default: false)
        create: z.boolean().default(false),
        // Removes the old link if it's a symlink (default: false)
        relink: z.boolean().default(false),
        // Force removes the old link, file or folder, and forces a new link (default: false)
        force: z.boolean().default(false),
      })
      .default({
        create: false,
        relink: false,
        force: false,
      }),
    shell: z
      .object({
        // When true, suppresses command output messages (default: false)
        quiet: z.boolean().default(false),
      })
      .default({
        quiet: false,
      }),
  })
  .default({
    link: {
      create: false,
      relink: false,
      force: false,
    },
    shell: {
      quiet: false,
    },
  });

const ShellConfigSchema = z.object({
  description: z.string().optional(),
  command: z.string(),
  quiet: z.boolean().optional().default(false),
});

const PackageManagerConfigSchema = z.object({
  // Important for Brew on MacOS
  installSelf: z.boolean().optional().default(true),
  dependenciesFile: z.string(),
});

// Define your config schema with Zod
const ConfigSchema = z.object({
  defaults: DefaultsConfig,
  link: z.record(z.string(), z.string()),
  shell: z.array(ShellConfigSchema),
  packageManager: PackageManagerConfigSchema,
});

type Config = z.infer<typeof ConfigSchema>;

const generateShell = (config: Config): string => {
  let output = "#!/bin/bash\n\n";
  output += "# Generated by dotbash\n";

  // Exit on error
  output += "set -e\n\n";

  output += generateLinks(config);
  output += generatePackageManager(config);
  output += generateShellCommands(config);

  return output;
};

const generateLinks = (config: Config): string => {
  let output = "";
  const linkDefaults = config.defaults.link;

  // Generate Links
  for (const [destination, source] of Object.entries(config.link)) {
    output += `echo "Setting up: ${destination} -> ${source}"\n`;

    // Get the source path relative to the dotfiles directory
    const sourcePath = `\$(pwd)/${source}`;

    // Expand tilde in destination path
    const destPath = destination.startsWith("~")
      ? `\$HOME${destination.slice(1)}`
      : destination;

    // Check source exists in shell (better for runtime validation)
    output += `if [ ! -e "${sourcePath}" ]; then\n`;
    output += `  echo "  ✗ Error: Source does not exist: ${source}"\n`;
    output += `  exit 1\n`;
    output += `fi\n`;

    // Create parent directory if needed
    if (linkDefaults.create) {
      output += `mkdir -p "\$(dirname "${destPath}")"\n`;
    }

    // Handle existing links/files
    if (linkDefaults.force) {
      // Force remove anything at the destination
      output += `if [ -e "${destPath}" ] || [ -L "${destPath}" ]; then\n`;
      output += `  echo "  Removing existing: ${destination}"\n`;
      output += `  rm -rf "${destPath}"\n`;
      output += `fi\n`;
    } else if (linkDefaults.relink) {
      // Only remove if it's a symlink
      output += `if [ -L "${destPath}" ]; then\n`;
      output += `  echo "  Removing existing symlink: ${destination}"\n`;
      output += `  rm "${destPath}"\n`;
      output += `fi\n`;
    }

    // Create the symlink
    output += `ln -s "${sourcePath}" "${destPath}"\n`;
    output += `echo "  ✓ Linked ${destination}"\n\n`;
  }

  output += 'echo "All symlinks created successfully!"\n\n';

  return output;
};

const generateShellCommands = (config: Config): string => {
  let output = "";
  const shellDefaults = config.defaults.shell;

  // Generate shell commands
  for (const shellCmd of config.shell) {
    const description = shellCmd.description || "Running command";
    const command = shellCmd.command;
    const quiet = shellCmd.quiet ?? shellDefaults.quiet;

    output += `# ${description}\n`;

    if (!quiet) {
      output += `echo "${description}..."\n`;
    }

    // Run the command with error handling
    output += `if ${command}; then\n`;

    if (!quiet) {
      output += `  echo "  ✓ ${description} completed"\n`;
    }

    output += `else\n`;
    output += `  echo "  ✗ Error: ${description} failed"\n`;
    output += `  exit 1\n`;
    output += `fi\n\n`;
  }

  if (config.shell.length > 0) {
    output += 'echo "All shell commands completed successfully!"\n\n';
  }

  return output;
};

const generatePackageManager = (config: Config): string => {
  let output = "";
  const pkgMgr = config.packageManager;

  // Check if running on macOS
  output += `# Package Manager Setup\n`;
  output += `if [[ "\$(uname)" == "Darwin" ]]; then\n`;

  // Install Homebrew if needed
  if (pkgMgr.installSelf) {
    output += `  # Install Homebrew\n`;
    output += `  echo "Checking for Homebrew..."\n`;
    output += `  if command -v brew &>/dev/null; then\n`;
    output += `    echo "  ✓ Homebrew already installed"\n`;
    output += `  else\n`;
    output += `    echo "  Installing Homebrew..."\n`;
    output += `    if /bin/bash -c "\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"; then\n`;
    output += `      echo "  ✓ Homebrew installed successfully"\n`;
    output += `    else\n`;
    output += `      echo "  ✗ Error: Failed to install Homebrew"\n`;
    output += `      exit 1\n`;
    output += `    fi\n`;
    output += `  fi\n\n`;
  }

  // Install packages from Brewfile
  if (pkgMgr.dependenciesFile && pkgMgr.dependenciesFile.trim() !== "") {
    const brewfilePath = `\$(pwd)/${pkgMgr.dependenciesFile}`;
    
    output += `  # Install packages from Brewfile\n`;
    output += `  if [ ! -e "${brewfilePath}" ]; then\n`;
    output += `    echo "  ✗ Error: Brewfile not found: ${pkgMgr.dependenciesFile}"\n`;
    output += `    exit 1\n`;
    output += `  fi\n`;
    output += `  echo "Installing packages from ${pkgMgr.dependenciesFile}..."\n`;
    output += `  if brew bundle --file="${brewfilePath}"; then\n`;
    output += `    echo "  ✓ Packages installed successfully"\n`;
    output += `  else\n`;
    output += `    echo "  ✗ Error: Failed to install packages"\n`;
    output += `    exit 1\n`;
    output += `  fi\n`;
  }

  output += `fi\n\n`;

  return output;
};

export const parseConfig = async (input: string, output: string) => {
  const configFile = Bun.file(input);
  const rawConfig = await configFile.json();

  const config = ConfigSchema.parse(rawConfig);

  const generatedShell = generateShell(config);
  Bun.file(output).write(generatedShell);
};
